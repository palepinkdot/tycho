"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const tslib_1=require("tslib"),path_1=require("path"),tar_1=(0,tslib_1.__importDefault)(require("tar")),fs_extra_1=require("fs-extra"),Service_1=(0,tslib_1.__importDefault)(require("../../models/Service")),RecipePreview_1=(0,tslib_1.__importDefault)(require("../../models/RecipePreview")),Recipe_1=(0,tslib_1.__importDefault)(require("../../models/Recipe")),User_1=(0,tslib_1.__importDefault)(require("../../models/User")),async_helpers_1=require("../../helpers/async-helpers"),config_1=require("../../config"),environment_remote_1=require("../../environment-remote"),asar_helpers_1=require("../../helpers/asar-helpers"),apiBase_1=(0,tslib_1.__importDefault)(require("../apiBase")),auth_1=require("../utils/auth"),recipe_helpers_1=require("../../helpers/recipe-helpers"),service_helpers_1=require("../../helpers/service-helpers"),debug=require("debug")("Ferdi:ServerApi");module.paths.unshift((0,recipe_helpers_1.getDevRecipeDirectory)(),(0,recipe_helpers_1.getRecipeDirectory)());class ServerApi{constructor(){this.recipePreviews=[],this.recipes=[]}async login(e,t){const r=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/auth/login`,{method:"POST",headers:{Authorization:`Basic ${window.btoa(`${e}:${t}`)}`}},!1);if(!r.ok)throw new Error(r.statusText);const s=await r.json();return debug("ServerApi::login resolves",s),s.token}async signup(e){const t=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/auth/signup`,{method:"POST",body:JSON.stringify(e)},!1);if(!t.ok)throw new Error(t.statusText);const r=await t.json();return debug("ServerApi::signup resolves",r),r.token}async inviteUser(e){const t=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/invite`,{method:"POST",body:JSON.stringify(e)});if(!t.ok)throw new Error(t.statusText);return debug("ServerApi::inviteUser"),!0}async retrievePassword(e){const t=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/auth/password`,{method:"POST",body:JSON.stringify({email:e})},!1);if(!t.ok)throw new Error(t.statusText);const r=await t.json();return debug("ServerApi::retrievePassword"),r}async userInfo(){if((0,apiBase_1.default)()===config_1.SERVER_NOT_LOADED)throw new Error("Server not loaded");const e=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/me`);if(!e.ok)throw new Error(e.statusText);const t=await e.json(),r=new User_1.default(t);return debug("ServerApi::userInfo resolves",r),r}async updateUserInfo(e){const t=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/me`,{method:"PUT",body:JSON.stringify(e)});if(!t.ok)throw new Error(t.statusText);const r=await t.json(),s=Object.assign(r,{data:new User_1.default(r.data)});return debug("ServerApi::updateUserInfo resolves",s),s}async deleteAccount(){const e=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/me`,{method:"DELETE"});if(!e.ok)throw new Error(e.statusText);const t=await e.json();return debug("ServerApi::deleteAccount resolves",t),t}async getServices(){if((0,apiBase_1.default)()===config_1.SERVER_NOT_LOADED)throw new Error("Server not loaded");const e=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/me/services`);if(!e.ok)throw new Error(e.statusText);const t=await e.json(),r=(await this._mapServiceModels(t)).filter((e=>!!e));return debug("ServerApi::getServices resolves",r),r}async createService(e,t){const r=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/service`,{method:"POST",body:JSON.stringify({recipeId:e,...t})});if(!r.ok)throw new Error(r.statusText);const s=await r.json();if(t.iconFile){const e=await this.uploadServiceIcon(s.data.id,t.iconFile);s.data=e}const a=Object.assign(s,{data:await this._prepareServiceModel(s.data)});return debug("ServerApi::createService resolves",a),a}async updateService(e,t){const r=t;r.iconFile&&await this.uploadServiceIcon(e,r.iconFile);const s=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/service/${e}`,{method:"PUT",body:JSON.stringify(r)});if(!s.ok)throw new Error(s.statusText);const a=await s.json(),i=Object.assign(a,{data:await this._prepareServiceModel(a.data)});return debug("ServerApi::updateService resolves",i),i}async uploadServiceIcon(e,t){const r=new FormData;r.append("icon",t);const s=(0,auth_1.prepareAuthRequest)({method:"PUT",body:r});delete s.headers["Content-Type"];const a=await window.fetch(`${(0,apiBase_1.default)()}/service/${e}`,s);if(!a.ok)throw new Error(a.statusText);return(await a.json()).data}async reorderService(e){const t=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/service/reorder`,{method:"PUT",body:JSON.stringify(e)});if(!t.ok)throw new Error(t.statusText);const r=await t.json();return debug("ServerApi::reorderService resolves",r),r}async deleteService(e){const t=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/service/${e}`,{method:"DELETE"});if(!t.ok)throw new Error(t.statusText);const r=await t.json();return(0,service_helpers_1.removeServicePartitionDirectory)(e,!0),debug("ServerApi::deleteService resolves",r),r}async getDefaultFeatures(){const e=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/features/default`);if(!e.ok)throw new Error(e.statusText);const t=await e.json();return debug("ServerApi::getDefaultFeatures resolves",t),t}async getFeatures(){if((0,apiBase_1.default)()===config_1.SERVER_NOT_LOADED)throw new Error("Server not loaded");const e=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/features`);if(!e.ok)throw new Error(e.statusText);const t=await e.json();return debug("ServerApi::getFeatures resolves",t),t}async getInstalledRecipes(){const e=(0,recipe_helpers_1.getRecipeDirectory)(),t=(0,fs_extra_1.readdirSync)(e).filter((t=>(0,fs_extra_1.statSync)((0,path_1.join)(e,t)).isDirectory()&&"temp"!==t&&"dev"!==t));return this.recipes=t.map((e=>new(require(e)(Recipe_1.default))((0,recipe_helpers_1.loadRecipeConfig)(e)))).filter((e=>e.id)),this.recipes=this.recipes.concat(this._getDevRecipes()),debug("StubServerApi::getInstalledRecipes resolves",this.recipes),this.recipes}async getRecipeUpdates(e){const t=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/recipes/update`,{method:"POST",body:JSON.stringify(e)});if(!t.ok)throw new Error(t.statusText);const r=await t.json();return debug("ServerApi::getRecipeUpdates resolves",r),r}async getRecipePreviews(){const e=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/recipes`);if(!e.ok)throw new Error(e.statusText);const t=await e.json(),r=this._mapRecipePreviewModel(t);return debug("ServerApi::getRecipes resolves",r),r}async getFeaturedRecipePreviews(){const e=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/recipes/popular`);if(!e.ok)throw new Error(e.statusText);const t=await e.json(),r=this._mapRecipePreviewModel(t);return debug("ServerApi::getFeaturedRecipes resolves",r),r}async searchRecipePreviews(e){const t=`${(0,apiBase_1.default)()}/recipes/search?needle=${e}`,r=await(0,auth_1.sendAuthRequest)(t);if(!r.ok)throw new Error(r.statusText);const s=await r.json(),a=this._mapRecipePreviewModel(s);return debug("ServerApi::searchRecipePreviews resolves",a),a}async getRecipePackage(e){const t=(0,environment_remote_1.userDataRecipesPath)(),r=(0,path_1.join)(t,"temp",e),s=(0,path_1.join)(r,"recipe.tar.gz"),a=(0,asar_helpers_1.asarRecipesPath)(`${e}.tar.gz`);let i;if((0,fs_extra_1.ensureDirSync)(r),(0,fs_extra_1.pathExistsSync)(a))debug("[ServerApi::getRecipePackage] Using internal recipe file"),i=a;else{debug("[ServerApi::getRecipePackage] Downloading recipe from server"),i=s;const t=`${(0,apiBase_1.default)()}/recipes/download/${e}`,r=await window.fetch(t);debug("Recipe downloaded",e);const a=await r.blob(),o=await a.arrayBuffer();(0,fs_extra_1.writeFileSync)(s,Buffer.from(o))}debug(i),await(0,async_helpers_1.sleep)(10),await tar_1.default.x({file:i,cwd:r,preservePaths:!0,unlink:!0,preserveOwner:!1,onwarn:t=>debug("warn",e,t)}),await(0,async_helpers_1.sleep)(10);const{id:o}=(0,fs_extra_1.readJsonSync)((0,path_1.join)(r,"package.json")),n=(0,path_1.join)(t,o);return(0,fs_extra_1.copySync)(r,n),(0,fs_extra_1.removeSync)(r),(0,fs_extra_1.removeSync)((0,path_1.join)(t,e,"recipe.tar.gz")),o}async healthCheck(){if((0,apiBase_1.default)()===config_1.SERVER_NOT_LOADED)throw new Error("Server not loaded");const e=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)(!1)}/health`,{method:"GET"},!1);if(!e.ok)throw new Error(e.statusText);debug("ServerApi::healthCheck resolves")}async getLegacyServices(){const e=(0,environment_remote_1.userDataPath)("settings","services.json");try{const t=(0,fs_extra_1.readJsonSync)(e);if(Object.prototype.hasOwnProperty.call(t,"services")){const e=await Promise.all(t.services.map((async e=>{const t=e,r=await(0,auth_1.sendAuthRequest)(`${(0,apiBase_1.default)()}/recipes/${e.service}`);if(200===r.status){const e=await r.json();t.recipe=new RecipePreview_1.default(e)}return t})));return debug("ServerApi::getLegacyServices resolves",e),e}}catch{console.error("ServerApi::getLegacyServices no config found")}return[]}async _mapServiceModels(e){const t=e.map((e=>e.recipeId));return await this._bulkRecipeCheck(t),Promise.all(e.map((async e=>this._prepareServiceModel(e))))}async _prepareServiceModel(e){let t;try{return t=this.recipes.find((t=>t.id===e.recipeId)),t?new Service_1.default(e,t):(console.warn(`Recipe ${e.recipeId} not loaded`),null)}catch(e){return debug(e),null}}async _bulkRecipeCheck(e){const t=e.filter(((e,t,r)=>r.indexOf(e)===t));return Promise.all(t.map((async e=>{let t=this.recipes.find((t=>t.id===e));return t||(console.warn(`Recipe '${e}' not installed, trying to fetch from server`),await this.getRecipePackage(e),debug("Rerun ServerAPI::getInstalledRecipes"),await this.getInstalledRecipes(),t=this.recipes.find((t=>t.id===e)),t)?t:(console.warn(`Could not load recipe ${e}`),null)}))).catch((e=>console.error("Can't load recipe",e)))}_mapRecipePreviewModel(e){return e.map((e=>{try{return new RecipePreview_1.default(e)}catch(e){return console.error(e),null}})).filter((e=>null!==e))}_getDevRecipes(){const e=(0,recipe_helpers_1.getDevRecipeDirectory)();try{const t=(0,fs_extra_1.readdirSync)(e).filter((t=>(0,fs_extra_1.statSync)((0,path_1.join)(e,t)).isDirectory()&&"temp"!==t));return t.map((e=>{let t;try{return t=require(e)(Recipe_1.default),new t((0,recipe_helpers_1.loadRecipeConfig)(e))}catch(e){console.error(e)}return!1})).filter((e=>e.id)).map((e=>{const t=e;return t.icons={svg:`${t.path}/icon.svg`},t.local=!0,e}))}catch{return debug("Could not load dev recipes"),!1}}}exports.default=ServerApi;